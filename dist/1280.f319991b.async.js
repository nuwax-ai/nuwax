"use strict";(()=>{(self.webpackChunk=self.webpackChunk||[]).push([[1280],{25043:function(j,D,g){var E=g(67062),k=4;function v(W){return(0,E.Z)(W,k)}D.Z=v},21280:function(j,D,g){g.r(D),g.d(D,{render:function(){return ee}});var E=g(76293),k=g(66366),v=g(59953),W=g(97530),ne=g(293),te=g(9640),se=g(11495),s=g(27246),V=g(72820),p=g(71180),Q=g(25043),B=g(55247),ce=g(10716);function h(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:U(e),edges:K(e)};return p.Z(e.graph())||(t.value=Q.Z(e.graph())),t}function U(e){return B.Z(e.nodes(),function(t){var n=e.node(t),o=e.parent(t),i={v:t};return p.Z(n)||(i.value=n),p.Z(o)||(i.parent=o),i})}function K(e){return B.Z(e.edges(),function(t){var n=e.edge(t),o={v:t.v,w:t.w};return p.Z(t.name)||(o.name=t.name),p.Z(n)||(o.value=n),o})}function ie(e){var t=new Graph(e.options).setGraph(e.value);return _.each(e.nodes,function(n){t.setNode(n.v,n.value),n.parent&&t.setParent(n.v,n.parent)}),_.each(e.edges,function(n){t.setEdge({v:n.v,w:n.w,name:n.name},n.value)}),t}var J=g(22123),a=new Map,N=new Map,R=new Map,z=(0,s.eW)(()=>{N.clear(),R.clear(),a.clear()},"clear"),x=(0,s.eW)((e,t)=>{const n=N.get(t)||[];return s.cM.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),$=(0,s.eW)((e,t)=>{const n=N.get(t)||[];return s.cM.info("Descendants of ",t," is ",n),s.cM.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||x(e.v,t)||x(e.w,t)||n.includes(e.w):(s.cM.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),G=(0,s.eW)((e,t,n,o)=>{s.cM.warn("Copying children of ",e,"root",o,"data",t.node(e),o);const i=t.children(e)||[];e!==o&&i.push(e),s.cM.warn("Copying (nodes) clusterId",e,"nodes",i),i.forEach(r=>{if(t.children(r).length>0)G(r,t,n,o);else{const l=t.node(r);s.cM.info("cp ",r," to ",o," with parent ",e),n.setNode(r,l),o!==t.parent(r)&&(s.cM.warn("Setting parent",r,t.parent(r)),n.setParent(r,t.parent(r))),e!==o&&r!==e?(s.cM.debug("Setting parent",r,e),n.setParent(r,e)):(s.cM.info("In copy ",e,"root",o,"data",t.node(e),o),s.cM.debug("Not Setting parent for node=",r,"cluster!==rootId",e!==o,"node!==clusterId",r!==e));const u=t.edges(r);s.cM.debug("Copying Edges",u),u.forEach(d=>{s.cM.info("Edge",d);const M=t.edge(d.v,d.w,d.name);s.cM.info("Edge data",M,o);try{$(d,o)?(s.cM.info("Copying as ",d.v,d.w,M,d.name),n.setEdge(d.v,d.w,M,d.name),s.cM.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.cM.info("Skipping copy of edge ",d.v,"-->",d.w," rootId: ",o," clusterId:",e)}catch(m){s.cM.error(m)}})}s.cM.debug("Removing node",r),t.removeNode(r)})},"copy"),Y=(0,s.eW)((e,t)=>{const n=t.children(e);let o=[...n];for(const i of n)R.set(i,e),o=[...o,...Y(i,t)];return o},"extractDescendants"),L=(0,s.eW)((e,t,n)=>{const o=e.edges().filter(d=>d.v===t||d.w===t),i=e.edges().filter(d=>d.v===n||d.w===n),r=o.map(d=>({v:d.v===t?n:d.v,w:d.w===t?t:d.w})),l=i.map(d=>({v:d.v,w:d.w}));return r.filter(d=>l.some(M=>d.v===M.v&&d.w===M.w))},"findCommonEdges"),b=(0,s.eW)((e,t,n)=>{const o=t.children(e);if(s.cM.trace("Searching children of id ",e,o),o.length<1)return e;let i;for(const r of o){const l=b(r,t,n),u=L(t,n,l);if(l)if(u.length>0)i=l;else return l}return i},"findNonClusterChild"),Z=(0,s.eW)(e=>!a.has(e)||!a.get(e).externalConnections?e:a.has(e)?a.get(e).id:e,"getAnchorId"),I=(0,s.eW)((e,t)=>{if(!e||t>10){s.cM.debug("Opting out, no graph ");return}else s.cM.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.cM.warn("Cluster identified",n," Replacement id in edges: ",b(n,e,n)),N.set(n,Y(n,e)),a.set(n,{id:b(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const o=e.children(n),i=e.edges();o.length>0?(s.cM.debug("Cluster identified",n,N),i.forEach(r=>{const l=x(r.v,n),u=x(r.w,n);l^u&&(s.cM.warn("Edge: ",r," leaves cluster ",n),s.cM.warn("Descendants of XXX ",n,": ",N.get(n)),a.get(n).externalConnections=!0)})):s.cM.debug("Not a cluster ",n,N)});for(let n of a.keys()){const o=a.get(n).id,i=e.parent(o);i!==n&&a.has(i)&&!a.get(i).externalConnections&&(a.get(n).id=i)}e.edges().forEach(function(n){const o=e.edge(n);s.cM.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.cM.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let i=n.v,r=n.w;if(s.cM.warn("Fix XXX",a,"ids:",n.v,n.w,"Translating: ",a.get(n.v)," --- ",a.get(n.w)),a.get(n.v)||a.get(n.w)){if(s.cM.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),i=Z(n.v),r=Z(n.w),e.removeEdge(n.v,n.w,n.name),i!==n.v){const l=e.parent(i);a.get(l).externalConnections=!0,o.fromCluster=n.v}if(r!==n.w){const l=e.parent(r);a.get(l).externalConnections=!0,o.toCluster=n.w}s.cM.warn("Fix Replacing with XXX",i,r,n.name),e.setEdge(i,r,o,n.name)}}),s.cM.warn("Adjusted Graph",h(e)),T(e,0),s.cM.trace(a)},"adjustClustersAndEdges"),T=(0,s.eW)((e,t)=>{if(s.cM.warn("extractor - ",t,h(e),e.children("D")),t>10){s.cM.error("Bailing out");return}let n=e.nodes(),o=!1;for(const i of n){const r=e.children(i);o=o||r.length>0}if(!o){s.cM.debug("Done, no node has children",e.nodes());return}s.cM.debug("Nodes = ",n,t);for(const i of n)if(s.cM.debug("Extracting node",i,a,a.has(i)&&!a.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",t),!a.has(i))s.cM.debug("Not a cluster",i,t);else if(!a.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){s.cM.warn("Cluster without external connections, without a parent and with children",i,t);let l=e.graph().rankdir==="TB"?"LR":"TB";a.get(i)?.clusterData?.dir&&(l=a.get(i).clusterData.dir,s.cM.warn("Fixing dir",a.get(i).clusterData.dir,l));const u=new J.k({multigraph:!0,compound:!0}).setGraph({rankdir:l,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.cM.warn("Old graph before copy",h(e)),G(i,e,u,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:a.get(i).clusterData,label:a.get(i).label,graph:u}),s.cM.warn("New graph after copy node: (",i,")",h(u)),s.cM.debug("Old graph after copy",h(e))}else s.cM.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!a.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),t),s.cM.debug(a);n=e.nodes(),s.cM.warn("New list of nodes",n);for(const i of n){const r=e.node(i);s.cM.warn(" Now next level",i,r),r?.clusterNode&&T(r.graph,t+1)}},"extractor"),H=(0,s.eW)((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(o=>{const i=e.children(o),r=H(e,i);n=[...n,...r]}),n},"sorter"),q=(0,s.eW)(e=>H(e,e.children()),"sortNodesByHierarchy"),F=(0,s.eW)(async(e,t,n,o,i,r)=>{s.cM.warn("Graph in recursive render:XAX",h(t),i);const l=t.graph().rankdir;s.cM.trace("Dir in recursive render - dir:",l);const u=e.insert("g").attr("class","root");t.nodes()?s.cM.info("Recursive render XXX",t.nodes()):s.cM.info("No nodes found for",t),t.edges().length>0&&s.cM.info("Recursive edges",t.edge(t.edges()[0]));const d=u.insert("g").attr("class","clusters"),M=u.insert("g").attr("class","edgePaths"),m=u.insert("g").attr("class","edgeLabels"),X=u.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(f){const c=t.node(f);if(i!==void 0){const w=JSON.parse(JSON.stringify(i.clusterData));s.cM.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,w.height,`
Parent cluster`,i.height),t.setNode(i.id,w),t.parent(f)||(s.cM.trace("Setting parent",f,i.id),t.setParent(f,i.id,w))}if(s.cM.info("(Insert) Node XXX"+f+": "+JSON.stringify(t.node(f))),c?.clusterNode){s.cM.info("Cluster identified XBX",f,c.width,t.node(f));const{ranksep:w,nodesep:C}=t.graph();c.graph.setGraph({...c.graph.graph(),ranksep:w+25,nodesep:C});const S=await F(X,c.graph,n,o,t.node(f),r),O=S.elem;(0,v.jr)(c,O),c.diff=S.diff||0,s.cM.info("New compound node after recursive render XAX",f,"width",c.width,"height",c.height),(0,v.Yn)(O,c)}else t.children(f).length>0?(s.cM.trace("Cluster - the non recursive path XBX",f,c.id,c,c.width,"Graph:",t),s.cM.trace(b(c.id,t)),a.set(c.id,{id:b(c.id,t),node:c})):(s.cM.trace("Node - the non recursive path XAX",f,X,t.node(f),l),await(0,v.Lf)(X,t.node(f),{config:r,dir:l}))})),await(0,s.eW)(async()=>{const f=t.edges().map(async function(c){const w=t.edge(c.v,c.w,c.name);s.cM.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c)),s.cM.info("Edge "+c.v+" -> "+c.w+": ",c," ",JSON.stringify(t.edge(c))),s.cM.info("Fix",a,"ids:",c.v,c.w,"Translating: ",a.get(c.v),a.get(c.w)),await(0,E.I_)(m,w)});await Promise.all(f)},"processEdges")(),s.cM.info("Graph before layout:",JSON.stringify(h(t))),s.cM.info("############################################# XXX"),s.cM.info("###                Layout                 ### XXX"),s.cM.info("############################################# XXX"),(0,V.bK)(t),s.cM.info("Graph after layout:",JSON.stringify(h(t)));let A=0,{subGraphTitleTotalMargin:P}=(0,W.L)(r);return await Promise.all(q(t).map(async function(f){const c=t.node(f);if(s.cM.info("Position XBX => "+f+": ("+c.x,","+c.y,") width: ",c.width," height: ",c.height),c?.clusterNode)c.y+=P,s.cM.info("A tainted cluster node XBX1",f,c.id,c.width,c.height,c.x,c.y,t.parent(f)),a.get(c.id).node=c,(0,v.aH)(c);else if(t.children(f).length>0){s.cM.info("A pure cluster node XBX1",f,c.id,c.x,c.y,c.width,c.height,t.parent(f)),c.height+=P,t.node(c.parentId);const w=c?.padding/2||0,C=c?.labelBBox?.height||0,S=C-w||0;s.cM.debug("OffsetY",S,"labelHeight",C,"halfPadding",w),await(0,v.us)(d,c),a.get(c.id).node=c}else{const w=t.node(c.parentId);c.y+=P/2,s.cM.info("A regular node XBX1 - using the padding",c.id,"parent",c.parentId,c.width,c.height,c.x,c.y,"offsetY",c.offsetY,"parent",w,w?.offsetY,c),(0,v.aH)(c)}})),t.edges().forEach(function(f){const c=t.edge(f);s.cM.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(c),c),c.points.forEach(O=>O.y+=P/2);const w=t.node(f.v);var C=t.node(f.w);const S=(0,E.QP)(M,c,a,n,w,C,o);(0,E.Jj)(c,S)}),t.nodes().forEach(function(f){const c=t.node(f);s.cM.info(f,c.type,c.diff),c.isGroup&&(A=c.diff)}),s.cM.warn("Returning from recursive render XAX",u,A),{elem:u,diff:A}},"recursiveRender"),ee=(0,s.eW)(async(e,t)=>{const n=new J.k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=t.select("g");(0,E.DQ)(o,e.markers,e.type,e.diagramId),(0,v.gU)(),(0,E.ZH)(),(0,v.ZH)(),z(),e.nodes.forEach(r=>{n.setNode(r.id,{...r}),r.parentId&&n.setParent(r.id,r.parentId)}),s.cM.debug("Edges:",e.edges),e.edges.forEach(r=>{if(r.start===r.end){const l=r.start,u=l+"---"+l+"---1",d=l+"---"+l+"---2",M=n.node(l);n.setNode(u,{domId:u,id:u,parentId:M.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(u,M.parentId),n.setNode(d,{domId:d,id:d,parentId:M.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(d,M.parentId);const m=structuredClone(r),X=structuredClone(r),y=structuredClone(r);m.label="",m.arrowTypeEnd="none",m.id=l+"-cyclic-special-1",X.arrowTypeStart="none",X.arrowTypeEnd="none",X.id=l+"-cyclic-special-mid",y.label="",M.isGroup&&(m.fromCluster=l,y.toCluster=l),y.id=l+"-cyclic-special-2",y.arrowTypeStart="none",n.setEdge(l,u,m,l+"-cyclic-special-0"),n.setEdge(u,d,X,l+"-cyclic-special-1"),n.setEdge(d,l,y,l+"-cyc<lic-special-2")}else n.setEdge(r.start,r.end,{...r},r.id)}),s.cM.warn("Graph at first:",JSON.stringify(h(n))),I(n),s.cM.warn("Graph after XAX:",JSON.stringify(h(n)));const i=(0,s.nV)();await F(o,n,e.type,e.diagramId,void 0,i)},"render")}}]);})();
